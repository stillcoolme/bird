## 基础中的基础
> 重载 重写

重载：不同的方法签名

重写：相同的方法签名，子类覆盖掉父类实现

> equals与==的区别

* == : 判断两个变量或实例是不是指向同一个内存空间。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。
* equals() : 判断两个变量或对象所指向的内存空间的值是不是相同。但它一般有两种使用情况：
    * 情况 1：类没有覆盖 equals() 方法。等价于通过“==”比较这两个对象。
    * 情况 2：类覆盖了 equals() 方法。若它们的内容相等，则返回 true (即，认为这两个对象相等)。
* hashCode()用于哈希查找，因为hash冲突，hashcode()不能够保证不同的输入能得出不同的输出。
    * 所以hashcode()相等的对象，equals()不要求一定相等，可能是不同的对象。
    * equals()相等， hashcode() 也可能不等，但是要保证相等！！！
        * 所以，重写了equals()一般都要重写hashCode()，不然可能某两个对象明明是“相等”，而hashCode却不一样。
        * 具有哈希功能的Collection、Map中用到是先比对hashcode()，再看equals()。(时间复杂度低，一个一个字符equals很慢）

**hashCode() 的默认行为是对堆上的对象产生独特值**。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）


> String为什么是final的


## Lock

* 悲观锁

synchronized和Lock都是悲观锁，它们认为当使用数据的时候一定有其它线程来修改，

所以在获取数据的时候就会加锁，确保不会被其它线程修改。

* 乐观锁

它认为使用数据的时候不会有别的线程来修改数据，所以不会加锁。

只要在自身要进行update操作的时候，才会去判断之前的数据是否被别的线程修改了。

如果没有被修改则会修改成功，相反则会修改不成功。

这里最典型的是java.util.concurrent并发包中的递增操作就通过CAS自旋实现的。

在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。

----

不过从jdk1.8之后java已经对synchronized做了优化，性能上有了大幅度的提升。

乐观锁CAS，也不是那么十全十美，目前它存在三个大问题。 
1. ABA问题(JDK1.5之后已有解决方案) 
2. 循环时间长开销大 
3. 能保证一个共享变量的原子操作(JDK1.5之后已有解决方案)
