看了很多别人的文章，对NIO还是一知半解的状态。现在站在一个实践的角度，写一些我自己关于NIO的见解，

站在实践过后的高度下再回去看概念，应该对概念会有一个更好的理解。

### 基于BIO实现一个简易单线程服务器

服务端从启动到收到客户端数据的这个过程，将会有两次阻塞的过程(BIO的非常重要的一个特点):
1. 服务器端在启动后，首先需要等待客户端的连接请求（第一次阻塞），如果没有客户端连接，服务端将一直阻塞等待
2. 然后当客户端连接后，服务器会等待客户端发送数据（第二次阻塞），如果客户端没有发送数据，那么服务端将会一直阻塞等待客户端发送数据。

### BIO多线程服务器
在单线程条件下BIO不能处理多个客户端的请求。

如果需要处理多个客户端请求，要在每一个连接请求到来时，创建一个线程去执行这个连接请求，

这也就是为什么BIO的其中一条概念是服务器实现模式为一个连接一个线程。

多线程BIO服务器的弊端
* 如果有大量的请求连接到我们的服务器上却不发送消息，服务器也为这些不发送消息的请求创建一个单独的线程，连接数一多就会对服务端造成极大的压力。
* 所以如果这种不活跃的线程比较多，我们应该采取单线程的一个解决方案，但是单线程又无法处理并发，这就陷入了一种很矛盾的状态，
于是就有了NIO。

### NIO
NIO需要解决的最根本的问题就是存在于BIO中的两个阻塞，分别是等待连接时的阻塞和等待数据时的阻塞。

NIOServer
* 将Socket连接存储在一个list集合中，每次等待客户端消息时都去List轮询，看消息是否准备好，如果准备好则直接打印消息。
* 从头到尾我们一直没有开启第二个线程，而是一直采用单线程来处理多个客户端的连接，解决了BIO在单线程模式下无法处理多客户端请求的问题，
* 但是采用了一个轮询的方式来接收消息，假设有1000万连接这种轮询的方式效率是极低的。

### 真实NIO中如何解决
* 在真实NIO中，并不会在Java层上来进行一个轮询，而是将轮询的这个步骤交给操作系统级别的系统调用（window:select函数，在linux:epoll），主动地去感知有数据的socket。

* 假如有五个请求，系统select会将五个请求从用户态空间全量复制一份到内核态空间，在内核态空间来判断每个请求是否准备好数据，避免了4次频繁的上下文切换。

### select
* select是一个阻塞函数，如果select没有查询到到有数据的请求，那么将会一直阻塞。

* 如果有一个或者多个请求已经准备好数据了，那么select将会先将有数据的文件描述符置位，然后select返回。返回后通过遍历查看哪个请求有数据。

select的缺点：
* 底层存储依赖bitmap，处理的请求是有上限的，为1024。
* 文件描述符是会置位的，如果当被置位的文件描述符需要重新使用时，需要重新赋空值。
* fd（文件描述符）从用户态拷贝到内核态仍然有一笔开销。
* select返回后还要再次遍历，来获知是哪一个请求有数据。

### poll函数
poll的工作原理和select很像，先来看一段poll内部使用的一个结构体。
struct pollfd{
    int fd;
    short events;
    short revents;
}

* poll同样会将所有的请求拷贝到内核态，和select一样，poll同样是一个阻塞函数，
* 当一个或多个请求有数据的时候，也同样会进行置位，但是它置位的是结构体pollfd中的events或者revents置位，而不是对fd本身进行置位
所以在下一次使用的时候不需要再进行重新赋空值的操作。
* poll内部存储不依赖bitmap，而是使用pollfd数组的这样一个数据结构，数组的大小肯定是大于1024的。解决了select 1、2两点的缺点。

### epoll函数
epoll是最新的一种多路IO复用的函数。

* 它的fd是共享在用户态和内核态之间的，所以可以不必进行从用户态到内核态的一个拷贝，这样可以节约系统资源；
* 在select和poll中，如果某个请求的数据已经准备好，它们会将所有的请求都返回，供程序去遍历查看哪个请求存在数据，但是epoll只会返回存在数据的请求
* 这是因为epoll在发现某个请求存在数据时，首先会进行一个重排操作，将所有有数据的fd放到最前面的位置，然后返回（返回值为存在数据请求的个数N），那么我们的上层程序就可以不必将所有请求都轮询，而是直接遍历epoll返回的前N个请求，这些请求都是有数据的请求。


### 基本概念
https://blog.csdn.net/guanghuichenshao/article/details/79375967

先来个例子理解一下概念，以银行取款为例：
* 同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）。
* 异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）。
* 阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）。
* 非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）。

Java对BIO、NIO的支持：
* Java BIO (blocking I/O)： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
* Java NIO (non-blocking I/O)： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

BIO、NIO适用场景分析:
* BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。
* NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。

