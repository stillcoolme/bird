# 数据结构
### 时间空间复杂度，做完每道题都应该分析一下时间空间复杂度！

### 链表
* 反转链表，两两元素反转，判断链表是否有环
    
### 堆栈
* 判断括号是否有效20，用栈实现堆232，用堆实现栈225

### 哈希表、Set：用于查询和计数
* 有效的字母异位词242，2Sum1，3Sum15

### 优先队列（正常入，按优先级出）（由小顶堆，大顶堆，二叉搜索树实现）
* 流进的第K个最大的元素703，滑动窗口内最大的数239

### 二叉树，二叉搜索树（左子树小于根结点，右子树大于根节点）
* 验证二叉搜索树98，最小公共祖先235，
    
### trie树（字典树）
说句实话，工程上来说，和hash比起来，trie就是没有用的东西。这个可以说很深刻地表现出了一个学生和一个软件工程师的思维差异。
* hash类的算法都有可能因为碰撞而退化，而trie是稳定的复杂度，简直太招人喜欢了。但是工程师99.9%的情况下都会用hash。
* 因为，hash函数、map、set，都有内置库，所有语言都有。这意味着一个功能用hash就是五行代码，甚至体现不出用了hash，
* 而用trie，你要么先交一份trie开源库的分析选型比较报告来，要么自己撸一个，附带着先写一千行的单元测试用例，再跑个压测。
* 写出简单可用能快速上线的代码要更重要。

# 算法
### 递归，分治
递归：盗梦空间。
1. 先给定一个条件让你知道是否在梦境里，在第几层梦境（是否在递归里，同时让你知道在第几层，怎么返回）；
2. 然后是梦境里要做的事（业务逻辑）；
3. 然后是进下一层梦境（再调函数自己）。

分治：利用递归分而治之，子问题没有中间结果重复计算的，没有相关性，就可以同时在cpu多个核跑更快点。
中间结果重复计算就要动态规划或者保留中间结果。

* 众数169, 生成有效括号22

### 广度优先遍历BFS，深度优先遍历DFS
* 二叉树层次遍历102，二叉树的最小最大深度104 111

### 剪枝（搜索中常用的优化方法）

### 回溯（递归（重复计算））
包含问题所有解的解空间树中，将可能的结果搜索一遍，从而获得满足条件的解。

搜索过程采用深度遍历策略，并随时判定结点是否满足条件要求，满足要求就继续向下搜索，若不满足要求则回溯到上一层，这种解决问题的方法称为回溯法。

* N皇后51 52

### 动态规划（dp的p是递推）
1. 递归 + 记忆化(备忘数组) -> 递推
2. 状态的定义：opt[n], 
3. 状态得到 **状态** **选择** 方程：opt[n] = best_of(opt[n-1], opt[n-2],...)
4. 最优子结构

* 有些问题没有最优子结构，那你就得递归去算，就得重复去算，就退化成回溯。
* 走棋盘：从最后往前面推
* 股票买卖：多个维度的信息需要记录


# 技巧

* 双指针
* 参数传值，而不用返回值来传（98）

# 二刷首选
* 3
* 递归  51 52 152
* 动态规划 322 72 